From d6da2086951693e047fdd22b0d21c539ea1bb1e1 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Mon, 12 Dec 2016 13:08:17 -0500
Subject: Revert "damage: Make damageRegionProcessPending take a damage not a
 drawable"

The commit message makes the assertion that the code below damage is not
allowed to change whether there's a damage monitor for the drawable.
That turns out not to be the case! exa's mixed code, at least, will
create and destroy a damage in PrepareAccess. The destroy path can then
be catastrophic, as damageRegionProcessPending will attempt to
RegionEmpty memory from the middle of a freed block.

I'd wanted that invariant for performance, but faster isn't worth
broken, so revert it. I think what exa's doing is reasonable, so the
better way to improve performance for the unmonitored case is to either
revisit dynamically wrapping into the GC, or inline damage into dix.

This reverts commit 4e124203f2260daaf54155f4a05fe469733e0b97.

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1389886
Signed-off-by: Adam Jackson <ajax@redhat.com>
(cherry picked from commit 32e632e85894eddc3ace83f16f1e973b1be478fe)

diff --git a/miext/damage/damage.c b/miext/damage/damage.c
index 17c2abf..d6a3614 100644
--- a/miext/damage/damage.c
+++ b/miext/damage/damage.c
@@ -282,8 +282,10 @@ damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
 }
 
 static void
-damageRegionProcessPending(DamagePtr pDamage)
+damageRegionProcessPending(DrawablePtr pDrawable)
 {
+    drawableDamage(pDrawable);
+
     for (; pDamage != NULL; pDamage = pDamage->pNext) {
         if (pDamage->reportAfter) {
             /* It's possible that there is only interest in postRendering reporting. */
@@ -358,7 +360,6 @@ damageCreateGC(GCPtr pGC)
 
 #define DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable) \
     damageGCPriv(pGC);  \
-    drawableDamage(pDrawable); \
     const GCFuncs *oldFuncs = pGC->funcs; \
     unwrap(pGCPriv, pGC, funcs);  \
     unwrap(pGCPriv, pGC, ops); \
@@ -456,7 +457,7 @@ damageDestroyClip(GCPtr pGC)
 #define BOX_NOT_EMPTY(box) \
     (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))
 
-#define checkGCDamage(d,g)	(d && \
+#define checkGCDamage(d,g)	(getDrawableDamage(d) && \
 				 (!g->pCompositeClip ||\
 				  RegionNotEmpty(g->pCompositeClip)))
 
@@ -468,7 +469,8 @@ damageDestroyClip(GCPtr pGC)
     if(box.y2 > extents->y2) box.y2 = extents->y2; \
     }
 
-#define checkPictureDamage(d, p) (d && RegionNotEmpty(p->pCompositeClip))
+#define checkPictureDamage(p)	(getDrawableDamage(p->pDrawable) && \
+				 RegionNotEmpty(p->pCompositeClip))
 
 static void
 damageComposite(CARD8 op,
@@ -485,9 +487,8 @@ damageComposite(CARD8 op,
     PictureScreenPtr ps = GetPictureScreen(pScreen);
 
     damageScrPriv(pScreen);
-    drawableDamage(pDst->pDrawable);
 
-    if (checkPictureDamage(pDamage, pDst)) {
+    if (checkPictureDamage(pDst)) {
         BoxRec box;
 
         box.x1 = xDst + pDst->pDrawable->x;
@@ -504,7 +505,7 @@ damageComposite(CARD8 op,
                       pMask,
                       pDst,
                       xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDst->pDrawable);
     wrap(pScrPriv, ps, Composite, damageComposite);
 }
 
@@ -520,9 +521,8 @@ damageGlyphs(CARD8 op,
     PictureScreenPtr ps = GetPictureScreen(pScreen);
 
     damageScrPriv(pScreen);
-    drawableDamage(pDst->pDrawable);
 
-    if (checkPictureDamage(pDamage, pDst)) {
+    if (checkPictureDamage(pDst)) {
         int nlistTmp = nlist;
         GlyphListPtr listTmp = list;
         GlyphPtr *glyphsTmp = glyphs;
@@ -567,7 +567,7 @@ damageGlyphs(CARD8 op,
     }
     unwrap(pScrPriv, ps, Glyphs);
     (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDst->pDrawable);
     wrap(pScrPriv, ps, Glyphs, damageGlyphs);
 }
 
@@ -579,9 +579,8 @@ damageAddTraps(PicturePtr pPicture,
     PictureScreenPtr ps = GetPictureScreen(pScreen);
 
     damageScrPriv(pScreen);
-    drawableDamage(pPicture->pDrawable);
 
-    if (checkPictureDamage(pDamage, pPicture)) {
+    if (checkPictureDamage(pPicture)) {
         BoxRec box;
         int i;
         int x, y;
@@ -616,7 +615,7 @@ damageAddTraps(PicturePtr pPicture,
     }
     unwrap(pScrPriv, ps, AddTraps);
     (*ps->AddTraps) (pPicture, x_off, y_off, ntrap, traps);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pPicture->pDrawable);
     wrap(pScrPriv, ps, AddTraps, damageAddTraps);
 }
 
@@ -628,7 +627,7 @@ damageFillSpans(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (npt && checkGCDamage(pDamage, pGC)) {
+    if (npt && checkGCDamage(pDrawable, pGC)) {
         int nptTmp = npt;
         DDXPointPtr pptTmp = ppt;
         int *pwidthTmp = pwidth;
@@ -664,7 +663,7 @@ damageFillSpans(DrawablePtr pDrawable,
 
     (*pGC->ops->FillSpans) (pDrawable, pGC, npt, ppt, pwidth, fSorted);
 
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -676,7 +675,7 @@ damageSetSpans(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (npt && checkGCDamage(pDamage, pGC)) {
+    if (npt && checkGCDamage(pDrawable, pGC)) {
         DDXPointPtr pptTmp = ppt;
         int *pwidthTmp = pwidth;
         int nptTmp = npt;
@@ -710,7 +709,7 @@ damageSetSpans(DrawablePtr pDrawable,
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->SetSpans) (pDrawable, pGC, pcharsrc, ppt, pwidth, npt, fSorted);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -722,7 +721,7 @@ damagePutImage(DrawablePtr pDrawable,
                int y, int w, int h, int leftPad, int format, char *pImage)
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
-    if (checkGCDamage(pDamage, pGC)) {
+    if (checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
 
         box.x1 = x + pDrawable->x;
@@ -736,7 +735,7 @@ damagePutImage(DrawablePtr pDrawable,
     }
     (*pGC->ops->PutImage) (pDrawable, pGC, depth, x, y, w, h,
                            leftPad, format, pImage);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -750,7 +749,7 @@ damageCopyArea(DrawablePtr pSrc,
 
     DAMAGE_GC_OP_PROLOGUE(pGC, pDst);
 
-    if (checkGCDamage(pDamage, pGC)) {
+    if (checkGCDamage(pDst, pGC)) {
         BoxRec box;
 
         box.x1 = dstx + pDst->x;
@@ -765,7 +764,7 @@ damageCopyArea(DrawablePtr pSrc,
 
     ret = (*pGC->ops->CopyArea) (pSrc, pDst,
                                  pGC, srcx, srcy, width, height, dstx, dsty);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDst);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDst);
     return ret;
 }
@@ -783,7 +782,7 @@ damageCopyPlane(DrawablePtr pSrc,
 
     DAMAGE_GC_OP_PROLOGUE(pGC, pDst);
 
-    if (checkGCDamage(pDamage, pGC)) {
+    if (checkGCDamage(pDst, pGC)) {
         BoxRec box;
 
         box.x1 = dstx + pDst->x;
@@ -799,7 +798,7 @@ damageCopyPlane(DrawablePtr pSrc,
     ret = (*pGC->ops->CopyPlane) (pSrc, pDst,
                                   pGC, srcx, srcy, width, height, dstx, dsty,
                                   bitPlane);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDst);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDst);
     return ret;
 }
@@ -810,7 +809,7 @@ damagePolyPoint(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (npt && checkGCDamage(pDamage, pGC)) {
+    if (npt && checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
         int nptTmp = npt;
         xPoint *pptTmp = ppt;
@@ -840,7 +839,7 @@ damagePolyPoint(DrawablePtr pDrawable,
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->PolyPoint) (pDrawable, pGC, mode, npt, ppt);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -850,7 +849,7 @@ damagePolylines(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (npt && checkGCDamage(pDamage, pGC)) {
+    if (npt && checkGCDamage(pDrawable, pGC)) {
         int nptTmp = npt;
         DDXPointPtr pptTmp = ppt;
         BoxRec box;
@@ -913,7 +912,7 @@ damagePolylines(DrawablePtr pDrawable,
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->Polylines) (pDrawable, pGC, mode, npt, ppt);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -922,7 +921,7 @@ damagePolySegment(DrawablePtr pDrawable, GCPtr pGC, int nSeg, xSegment * pSeg)
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (nSeg && checkGCDamage(pDamage, pGC)) {
+    if (nSeg && checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
         int extra = pGC->lineWidth;
         int nsegTmp = nSeg;
@@ -992,7 +991,7 @@ damagePolySegment(DrawablePtr pDrawable, GCPtr pGC, int nSeg, xSegment * pSeg)
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->PolySegment) (pDrawable, pGC, nSeg, pSeg);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1002,7 +1001,7 @@ damagePolyRectangle(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (nRects && checkGCDamage(pDamage, pGC)) {
+    if (nRects && checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
         int offset1, offset2, offset3;
         int nRectsTmp = nRects;
@@ -1051,7 +1050,7 @@ damagePolyRectangle(DrawablePtr pDrawable,
         }
     }
     (*pGC->ops->PolyRectangle) (pDrawable, pGC, nRects, pRects);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1060,7 +1059,7 @@ damagePolyArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (nArcs && checkGCDamage(pDamage, pGC)) {
+    if (nArcs && checkGCDamage(pDrawable, pGC)) {
         int extra = pGC->lineWidth >> 1;
         BoxRec box;
         int nArcsTmp = nArcs;
@@ -1098,7 +1097,7 @@ damagePolyArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->PolyArc) (pDrawable, pGC, nArcs, pArcs);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1108,7 +1107,7 @@ damageFillPolygon(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (npt > 2 && checkGCDamage(pDamage, pGC)) {
+    if (npt > 2 && checkGCDamage(pDrawable, pGC)) {
         DDXPointPtr pptTmp = ppt;
         int nptTmp = npt;
         BoxRec box;
@@ -1157,7 +1156,7 @@ damageFillPolygon(DrawablePtr pDrawable,
     }
 
     (*pGC->ops->FillPolygon) (pDrawable, pGC, shape, mode, npt, ppt);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1166,7 +1165,7 @@ damagePolyFillRect(DrawablePtr pDrawable,
                    GCPtr pGC, int nRects, xRectangle *pRects)
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
-    if (nRects && checkGCDamage(pDamage, pGC)) {
+    if (nRects && checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
         xRectangle *pRectsTmp = pRects;
         int nRectsTmp = nRects;
@@ -1193,7 +1192,7 @@ damagePolyFillRect(DrawablePtr pDrawable,
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->PolyFillRect) (pDrawable, pGC, nRects, pRects);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1202,7 +1201,7 @@ damagePolyFillArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
 
-    if (nArcs && checkGCDamage(pDamage, pGC)) {
+    if (nArcs && checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
         int nArcsTmp = nArcs;
         xArc *pArcsTmp = pArcs;
@@ -1229,7 +1228,7 @@ damagePolyFillArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->PolyFillArc) (pDrawable, pGC, nArcs, pArcs);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1278,9 +1277,12 @@ damageDamageChars(DrawablePtr pDrawable,
 #define TT_IMAGE16 3
 
 static void
-damageText(DrawablePtr pDrawable, GCPtr pGC, int x, int y, unsigned long count,
-           char *chars, FontEncoding fontEncoding, DamagePtr pDamage,
-           Bool textType)
+damageText(DrawablePtr pDrawable,
+           GCPtr pGC,
+           int x,
+           int y,
+           unsigned long count,
+           char *chars, FontEncoding fontEncoding, Bool textType)
 {
     CharInfoPtr *charinfo;
     unsigned long i;
@@ -1289,7 +1291,7 @@ damageText(DrawablePtr pDrawable, GCPtr pGC, int x, int y, unsigned long count,
 
     imageblt = (textType == TT_IMAGE8) || (textType == TT_IMAGE16);
 
-    if (!pDamage)
+    if (!checkGCDamage(pDrawable, pGC))
         return;
 
     charinfo = xallocarray(count, sizeof(CharInfoPtr));
@@ -1314,9 +1316,9 @@ damagePolyText8(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
     damageText(pDrawable, pGC, x, y, (unsigned long) count, chars, Linear8Bit,
-               pDamage, TT_POLY8);
+               TT_POLY8);
     x = (*pGC->ops->PolyText8) (pDrawable, pGC, x, y, count, chars);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
     return x;
 }
@@ -1328,9 +1330,9 @@ damagePolyText16(DrawablePtr pDrawable,
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
     damageText(pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
                FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
-               pDamage, TT_POLY16);
+               TT_POLY16);
     x = (*pGC->ops->PolyText16) (pDrawable, pGC, x, y, count, chars);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
     return x;
 }
@@ -1341,9 +1343,9 @@ damageImageText8(DrawablePtr pDrawable,
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
     damageText(pDrawable, pGC, x, y, (unsigned long) count, chars, Linear8Bit,
-               pDamage, TT_IMAGE8);
+               TT_IMAGE8);
     (*pGC->ops->ImageText8) (pDrawable, pGC, x, y, count, chars);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1354,9 +1356,9 @@ damageImageText16(DrawablePtr pDrawable,
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
     damageText(pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
                FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
-               pDamage, TT_IMAGE16);
+               TT_IMAGE16);
     (*pGC->ops->ImageText16) (pDrawable, pGC, x, y, count, chars);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1371,7 +1373,7 @@ damageImageGlyphBlt(DrawablePtr pDrawable,
     damageDamageChars(pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
                       nglyph, ppci, TRUE, pGC->subWindowMode);
     (*pGC->ops->ImageGlyphBlt) (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1386,7 +1388,7 @@ damagePolyGlyphBlt(DrawablePtr pDrawable,
     damageDamageChars(pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
                       nglyph, ppci, FALSE, pGC->subWindowMode);
     (*pGC->ops->PolyGlyphBlt) (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1396,7 +1398,7 @@ damagePushPixels(GCPtr pGC,
                  DrawablePtr pDrawable, int dx, int dy, int xOrg, int yOrg)
 {
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
-    if (checkGCDamage(pDamage, pGC)) {
+    if (checkGCDamage(pDrawable, pGC)) {
         BoxRec box;
 
         box.x1 = xOrg;
@@ -1415,7 +1417,7 @@ damagePushPixels(GCPtr pGC,
             damageDamageBox(pDrawable, &box, pGC->subWindowMode);
     }
     (*pGC->ops->PushPixels) (pGC, pBitMap, pDrawable, dx, dy, xOrg, yOrg);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
     DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
 }
 
@@ -1480,7 +1482,6 @@ damageCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     ScreenPtr pScreen = pWindow->drawable.pScreen;
 
     damageScrPriv(pScreen);
-    drawableDamage(&pWindow->drawable);
 
     if (getWindowDamage(pWindow)) {
         int dx = pWindow->drawable.x - ptOldOrg.x;
@@ -1496,7 +1497,7 @@ damageCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     }
     unwrap(pScrPriv, pScreen, CopyWindow);
     (*pScreen->CopyWindow) (pWindow, ptOldOrg, prgnSrc);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(&pWindow->drawable);
     wrap(pScrPriv, pScreen, CopyWindow, damageCopyWindow);
 }
 
@@ -1870,22 +1871,20 @@ DamageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion)
 void
 DamageRegionProcessPending(DrawablePtr pDrawable)
 {
-    drawableDamage(pDrawable);
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
 }
 
 /* This call is very odd, i'm leaving it intact for API sake, but please don't use it. */
 void
 DamageDamageRegion(DrawablePtr pDrawable, RegionPtr pRegion)
 {
-    drawableDamage(pDrawable);
     damageRegionAppend(pDrawable, pRegion, FALSE, -1);
 
     /* Go back and report this damage for DamagePtrs with reportAfter set, since
      * this call isn't part of an in-progress drawing op in the call chain and
      * the DDX probably just wants to know about it right away.
      */
-    damageRegionProcessPending(pDamage);
+    damageRegionProcessPending(pDrawable);
 }
 
 void
-- 
cgit v0.10.2

From 1b42f9505ff3a39b441464f553442079b750fe88 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Thu, 8 Dec 2016 14:32:06 +1000
Subject: os: return 0 from check_timers if we touched any of them

Fixes a regression introduced in 0b2f30834b1a9f. If a driver posts input
events during a timer function (wacom and synaptics do this during tap
timeouts), ProcessInputEvents() is not called for these events. There are no
new events on any fds, so the events just sit in the queue waiting for
something else to happen.

Fix this by simply returning 0 from check_timers if we ran at least one of
them or reset them all. This way the callers ospoll_wait will exit and
continue with normal processing.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
Reviewed-by: Keith Packard <keithp@keithp.com>

diff --git a/os/WaitFor.c b/os/WaitFor.c
index ff1c85e..613608f 100644
--- a/os/WaitFor.c
+++ b/os/WaitFor.c
@@ -143,7 +143,7 @@ check_timers(void)
 {
     OsTimerPtr timer;
 
-    while ((timer = first_timer()) != NULL) {
+    if ((timer = first_timer()) != NULL) {
         CARD32 now = GetTimeInMillis();
         int timeout = timer->expires - now;
 
@@ -157,6 +157,8 @@ check_timers(void)
             /* time has rewound.  reset the timers. */
             CheckAllTimers();
         }
+
+        return 0;
     }
     return -1;
 }
-- 
cgit v0.10.2

From 05e19644250698aa126a60bc671e85425df784d1 Mon Sep 17 00:00:00 2001
From: Hans De Goede <hdegoede@redhat.com>
Date: Tue, 20 Dec 2016 13:00:43 +0100
Subject: glamor: Trust eglGetPlatformDisplayEXT if it exists

If the libEGL we are using has eglGetPlatformDisplayEXT, yet it still
returns NULL, then this very likely means that it does not support the
type (e.g. EGL_PLATFORM_GBM_MESA) passed in, and then returning NULL is
the right thing to do.

This avoids falling back to an eglGetDisplay() implementation which does
not understands the passed in gbm handle, treats it as a pointer to
something else completely, followed by a crash sooner or later.

Specifically this fixes using the nvidia binary driver, with nvidia's
libEGL + the modesetting driver on a secondary GPU crashing inside
glamor_egl_init() sometimes.

Cc: Eric Anholt <eric@anholt.net>
Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index 9cc0f8d..4bde637 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -769,6 +769,10 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
 
     glamor_egl->display = glamor_egl_get_display(EGL_PLATFORM_GBM_MESA,
                                                  glamor_egl->gbm);
+    if (!glamor_egl->display) {
+        xf86DrvMsg(scrn->scrnIndex, X_ERROR, "eglGetDisplay() failed\n");
+        goto error;
+    }
 #else
     glamor_egl->display = eglGetDisplay((EGLNativeDisplayType) (intptr_t) fd);
 #endif
diff --git a/glamor/glamor_egl.h b/glamor/glamor_egl.h
index 6b05f57..2c6d307 100644
--- a/glamor/glamor_egl.h
+++ b/glamor/glamor_egl.h
@@ -67,9 +67,7 @@ glamor_egl_get_display(EGLint type, void *native)
         PFNEGLGETPLATFORMDISPLAYEXTPROC getPlatformDisplayEXT =
             (void *) eglGetProcAddress("eglGetPlatformDisplayEXT");
         if (getPlatformDisplayEXT)
-            dpy = getPlatformDisplayEXT(type, native, NULL);
-        if (dpy)
-            return dpy;
+            return getPlatformDisplayEXT(type, native, NULL);
     }
 
     /* Welp, everything is awful. */
-- 
cgit v0.10.2

From e473b2bc016adacfe3fa47fdf6a8ce9f8cddff62 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <michel.daenzer@amd.com>
Date: Fri, 25 Nov 2016 17:34:05 +0900
Subject: present: Only call present_flip_notify if vblank->queued == FALSE

We are no longer using the present_flip_queue list only for presents
which have already been submitted to the driver for page flipping, but
also for those which we are queueing up to be flipped later, marked
with vblank->queued == TRUE. We were incorrectly calling
present_flip_notify for such entries, failing the assertion in
present_flip_notify (or presumably resulting in other undesirable
behaviour with assertions disabled).

Reproduction recipe: Run the JavaFX test case referenced by
https://bugs.freedesktop.org/show_bug.cgi?id=98831#c6 and alt-tab out
of it while it's fullscreen. May take a few attempts to hit the
assertion failure.

Fixes: bab0f450a719 ("present: Fix presentation of flips out of order")
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=98854
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/present/present.c b/present/present.c
index a7ca06e..ef89045 100644
--- a/present/present.c
+++ b/present/present.c
@@ -536,7 +536,10 @@ present_event_notify(uint64_t event_id, uint64_t ust, uint64_t msc)
     }
     xorg_list_for_each_entry(vblank, &present_flip_queue, event_queue) {
         if (vblank->event_id == event_id) {
-            present_flip_notify(vblank, ust, msc);
+            if (vblank->queued)
+                present_execute(vblank, ust, msc);
+            else
+                present_flip_notify(vblank, ust, msc);
             return;
         }
     }
-- 
cgit v0.10.2

From: Keith Packard <keithp@keithp.com>
X-Patchwork-Id: 132089
Message-Id: <20170110021441.12759-1-keithp@keithp.com>
To: xorg-devel@lists.freedesktop.org
Date: Mon,  9 Jan 2017 18:14:41 -0800

A client which is attended while a grab is blocking execution of its
requests needs to be placed in the saved_ready_clients list so that it
will get scheduled once the grab terminates. Otherwise, if the client
never sends another request, there is no way for it to be placed in
the ready_clients list.

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99333
Signed-off-by: Keith Packard <keithp@keithp.com>
---
 dix/dispatch.c      | 7 +++++++
 include/dixstruct.h | 3 +++
 os/connection.c     | 4 ++++
 3 files changed, 14 insertions(+)

diff --git a/dix/dispatch.c b/dix/dispatch.c
index 3d0fe26fd..ab69d34b9 100644
--- a/dix/dispatch.c
+++ b/dix/dispatch.c
@@ -266,6 +266,13 @@ mark_client_ready(ClientPtr client)
         xorg_list_append(&client->ready, &ready_clients);
 }
 
+/* Client has requests queued or data on the network, but awaits a server grab release */
+void mark_client_saved_ready(ClientPtr client)
+{
+    if (xorg_list_is_empty(&client->ready))
+        xorg_list_append(&client->ready, &saved_ready_clients);
+}
+
 /* Client has no requests queued and no data on network */
 void
 mark_client_not_ready(ClientPtr client)
diff --git a/include/dixstruct.h b/include/dixstruct.h
index d71b0ac05..fd9195972 100644
--- a/include/dixstruct.h
+++ b/include/dixstruct.h
@@ -143,6 +143,9 @@ extern void SmartScheduleStopTimer(void);
 /* Client has requests queued or data on the network */
 void mark_client_ready(ClientPtr client);
 
+/* Client has requests queued or data on the network, but awaits a server grab release */
+void mark_client_saved_ready(ClientPtr client);
+
 /* Client has no requests queued and no data on network */
 void mark_client_not_ready(ClientPtr client);
 
diff --git a/os/connection.c b/os/connection.c
index a901ebf3c..a2629c8a2 100644
--- a/os/connection.c
+++ b/os/connection.c
@@ -1067,6 +1067,10 @@ AttendClient(ClientPtr client)
     set_poll_client(client);
     if (listen_to_client(client))
         mark_client_ready(client);
+    else if (!(oc->flags & OS_COMM_IGNORED)) {
+        /* grab active, mark ready when grab goes away */
+        mark_client_saved_ready(client);
+    }
 }
 
 /* make client impervious to grabs; assume only executing client calls this */

